\begin{center}
	\includegraphics[width=0.3\textwidth]{content/chapter-12/images/1}
\end{center}

第2章向介绍了将工作导向特定设备的机制——控制代码执行的位置。本章中，我们将探索如何适应运行时出现的设备。\par

我们希望程序可以移植，程序需要适应设备的功能。我们可以将程序参数化，只使用现有的特性，并根据设备的具体情况调整代码。如果程序不能适应环境，那么糟糕的事情就会发生，包括执行缓慢或失败。\par

幸运的是，SYCL规范的创建者考虑到了这一点，并为提供了解决这个问题的接口。SYCL规范定义了一个设备类，封装了可以执行内核的设备。查询设备类的能力，使程序能够适应设备的特性和能力，这是本章的核心内容。\par

我们中的许多人将从逻辑开始思考“是否存在GPU?”通知程序在执行时做出的选择，这是本章的开始。正如我们将看到的，有更多的信息可以帮助我们使程序健壮和性能良好。\par

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
对程序进行参数化可以帮助提高程序的正确性、可移植性、性能可移植性。
\end{tcolorbox}

本章将深入探讨查询，以及如何在程序中如何有效地使用。\par

设备特定的属性可以使用get\_info查询，但是DPC++不同于SYCL 1.2.1，完全重载了get\_info，以减少使用get\_work\_group\_info获取工作组信息，而工作组信息实际上是设备特定的信息。DPC++不支持get\_work\_group\_info，这意味着特定于设备的内核和工作组属性可以作为查询特定于设备的属性(get\_info)。这纠正了SYCL 1.2.1中存在的从OpenCL继承而来的历史问题。\par

















































